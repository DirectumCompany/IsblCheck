<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="NotUsedVarRuleDescription" xml:space="preserve">
    <value>Правило поиска не используемых переменных.</value>
  </data>
  <data name="NotUsedVariable" xml:space="preserve">
    <value>Неиспользуемая переменная {0}.</value>
  </data>
  <data name="UsingNotAssignedVariable" xml:space="preserve">
    <value>Использование необъявленной переменной "{0}".</value>
  </data>
  <data name="UsingNotAssignedVarRuleDescription" xml:space="preserve">
    <value>Правило поиска не означенных переменных.</value>
  </data>
  <data name="UsingRedefindedVarRuleDescription" xml:space="preserve">
    <value>Правило поиска переменных переопределенных до их использования.</value>
  </data>
  <data name="VariableCanHasUncertainedValue" xml:space="preserve">
    <value>Переменная "{0}" объявлена во внутреннем блоке кода и может иметь неопределенное значение.</value>
  </data>
  <data name="VariableIsRedefinedBeforeUsing" xml:space="preserve">
    <value>Переменная "{0}" была переопределена до её использования.</value>
  </data>
  <data name="ObjectDoesNotRestoreSelfStatus" xml:space="preserve">
    <value>Для объекта "{0}" не восстанавливается его первоначальное состояние.</value>
  </data>
  <data name="RecoveryObjectStateRuleDescription" xml:space="preserve">
    <value>Правило поиска объектов не восстанавливающих свое состояние.</value>
  </data>
  <data name="IncorrectFormatStringRuleDescription" xml:space="preserve">
    <value>Правило для проверки строк форматирования</value>
  </data>
  <data name="ArgumentForTemplateNotFound" xml:space="preserve">
    <value>Ошибка форматирования строки. Не найден аргумент для описателя "{0}" (ожидается аргумент с индексом {1}). Шаблон строки: "{2}".</value>
  </data>
  <data name="RedutantFormatArgument" xml:space="preserve">
    <value>Для аргумента "{0}" с индексом {1} не найден соответствующий описатель. Шаблон строки: "{2}".</value>
  </data>
  <data name="SingleFormatArgumentRuleDescription" xml:space="preserve">
    <value>Правило для обнаружения вызовов функций Format, LoadStringFormat, в которые передаётся одно значение через ArrayOf</value>
  </data>
  <data name="SingleArgumentForFormatFunction" xml:space="preserve">
    <value>В функцию форматирования строки передаётся одно значение - не нужно использовать массив</value>
  </data>
  <data name="EmptyFormatArgument" xml:space="preserve">
    <value>Для описателя "{0}" передан пустой аргумент. Будет использовано значение по умолчанию. Шаблон строки: "{1}".</value>
  </data>
  <data name="IncorrectFunctionParamsCountRuleDescription" xml:space="preserve">
    <value>Правило поиска вызовов функций с неверным количеством параметров</value>
  </data>
  <data name="WrongFunctionArgumentsCount" xml:space="preserve">
    <value>Неверное количество параметров при вызове функции</value>
  </data>
  <data name="FunctionWithoutHelpRuleDescription" xml:space="preserve">
    <value>Правило для проверки наличия справки у функций</value>
  </data>
  <data name="NoFunctionHelp" xml:space="preserve">
    <value>Отсутствует справка к функции</value>
  </data>
  <data name="LocalizationStringNotFound" xml:space="preserve">
    <value>Использование несуществующей строки локализации "{0}.{1}"</value>
  </data>
  <data name="UsingNonExistingLocalizationStringRuleDescription" xml:space="preserve">
    <value>Правило поиска мест использования несуществующих строк локализации</value>
  </data>
  <data name="ExceptionClassNotSpecified" xml:space="preserve">
    <value>Должен быть заполнен класс исключения</value>
  </data>
  <data name="ExceptionClassNotSpecifiedRuleDescription" xml:space="preserve">
    <value>Правило, по которому при создании исключения должен указываться класс исключения</value>
  </data>
  <data name="FunctionTooBig" xml:space="preserve">
    <value>Длина функции более {0} строк, возможно требуется рефакторинг</value>
  </data>
  <data name="FunctionTooBigRuleDescription" xml:space="preserve">
    <value>Правило ограничения максимальной длины функции.</value>
  </data>
  <data name="UsingTrueFalseKeywords" xml:space="preserve">
    <value>Использование констант True и False в качестве аргументов логического выражения.</value>
  </data>
  <data name="UsingTrueFalseKeywordsRuleDescription" xml:space="preserve">
    <value>Правило о том, что нельзя использовать константы True и False в логическом выражении.</value>
  </data>
  <data name="SelfAssignmentVarRuleDescription" xml:space="preserve">
    <value>Выражение "{0}" присваивается самому себе. Возможно опечатка.</value>
  </data>
  <data name="UsingNotExistedReference" xml:space="preserve">
    <value>Использование несуществующего справочника "{0}".</value>
  </data>
  <data name="UsingNotExistedReferenceRuleDescription" xml:space="preserve">
    <value>Правило поиска использования несуществующего справочника.</value>
  </data>
  <data name="UsingInfoReferenceDescription" xml:space="preserve">
    <value>Правило использования свойства Info.Reference.</value>
  </data>
  <data name="UsingInfoReferenceRule" xml:space="preserve">
    <value>Использование свойства Info.Reference нежелательно, это свойство не всегда указывает на верную запись.</value>
  </data>
  <data name="InteractiveWindowsOnEvents" xml:space="preserve">
    <value>В событии "{0}" не рекомендуется использовать функции, выводящие диалоговые окна.</value>
  </data>
  <data name="InteractiveWindowsOnEventsRuleDescription" xml:space="preserve">
    <value>Правило поиска использования интерактивных окон в событиях справочника</value>
  </data>
  <data name="TodoDoneComments" xml:space="preserve">
    <value>В коде не должно оставаться комментариев TODO и DONE: {0}...</value>
  </data>
  <data name="TodoDoneCommentsRuleDescription" xml:space="preserve">
    <value>Правило поиска комментариев TODO, DONE.</value>
  </data>
  <data name="InteractiveWindowsOnStronglyNumerationReferenceEvents" xml:space="preserve">
    <value>В событии "{0}" справочника со строгой нумерацией нельзя использовать функции, выводящие диалоговые окна.</value>
  </data>
</root>